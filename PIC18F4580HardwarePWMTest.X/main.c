/* 
 * File:   main.c
 * Author: Nishanth
 *  This project demonstrates change in pwm duty cycle  generated by ccp module
 *  on RC2 pin. The duty cycle changes with adc value received from RA0 pin.
 *  This is tested by connecting a joystick to RA0 and a motor Driver to RC2.
 *  This changes the speed of motor when joystick is moved.
 *  Motors rotate in reverse and forward when joystick is pushed forward and 
 *  backward. For this RC0 and RC1 pins are used
 *
 *
 * Created on 20 July, 2014, 8:15 PM
 */
#define _XTAL_FREQ 32000000
#define CYC_FREQ 8000000
#define CYC_DELAY 197120
#include <xc.h> 
#include <stdio.h>
#include <stdlib.h>
#include <plib/delays.h>
#include "user.h"
#include "system.h"
//#include <plib/adc.h>
#include <plib/pwm.h>
#include <plib/delays.h>




/*
 * 
 */
unsigned int ADCValue = 0;
unsigned int ADCValue9B = 0;
unsigned int ADCValue8B = 0;
unsigned int ADCValueFinal = 0;
unsigned int flag = 0;
int i = 0;
int j = 0;
int angle = 0;


//void incrementDelay(unsigned int value){
//    do {
//        _delay(500);
//    } while(--value != 0);
//}




void main(void) {
    ConfigureOscillator();
    InitApp();
    Delay10KTCYx(3);
    while(1){
              
        ADCON0bits.GO = 1;
        while(ADCON0bits.GO);
        ADCValue = (unsigned)(((unsigned int)ADRESH)<<8)|(ADRESL);
        ADCValue9B = ADCValue>>1;
        ADCValue8B = ADCValue>>2;

        if(ADCValue9B>=256){
            ADCValueFinal = ADCValue9B-256;
            LATCbits.LATC1 = 0b0;
            LATCbits.LATC0 = 0b1;
        }else{
            ADCValueFinal = 255-ADCValue9B;
            LATCbits.LATC1 = 0b1;
            LATCbits.LATC0 = 0b0;
        }


        if(ADCValueFinal>31){
            LATAbits.LA1 = 0b1;
        }else{
            LATAbits.LA1 = 0b0;
        }

        if(ADCValueFinal>63){
            LATAbits.LA2 = 0b1;
        }else{
            LATAbits.LA2 = 0b0;
        }
        if(ADCValueFinal>91){
            LATAbits.LA3 = 0b1;
        }else{
            LATAbits.LA3 = 0b0;
        }
        if(ADCValueFinal>127){
            LATAbits.LA4 = 0b1;
        }else{
            LATAbits.LA4 = 0b0;
        }
        if(ADCValueFinal>159){
            LATAbits.LA5 = 0b1;
        }else{
            LATAbits.LA5 = 0b0;
        }
        if(ADCValueFinal>191){
            LATAbits.LA6 = 0b1;
        }else{
            LATAbits.LA6 = 0b0;
        }
        if(ADCValueFinal>223){
            LATAbits.LA7 = 0b1;
        }else{
            LATAbits.LA7 = 0b0;
        }
        
        // PWM Code
        CCP1CONbits.DC1B = 0b00;
        CCPR1L = ADCValueFinal;
                
    }    
}

